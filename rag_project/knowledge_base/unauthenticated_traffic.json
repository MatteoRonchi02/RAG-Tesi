{
  "smell_name": "Unauthenticated Traffic",
  "brief_description": "Questo smell si riferisce al traffico tra microservizi che avviene senza alcuna forma di autenticazione. Anche se la comunicazione avviene all'interno di una rete considerata 'fidata', un aggressore che riesca a compromettere un servizio potrebbe impersonare altri servizi e inviare richieste non autorizzate, muovendosi lateralmente nell'architettura (lateral movement).",
  "microservices_context": [
    "api-gateway",
    "customer-core",
    "policy-management-backend",
    "risk-management-nodejs"
  ],
  "manifestations": [
    {
      "artifact_type": "Application Configuration",
      "language": "Java (Spring Security)",
      "negative_example": "http.authorizeRequests().antMatchers(\"/api/internal/**\").permitAll()",
      "explanation": "Gli endpoint destinati alla comunicazione interna tra servizi sono contrassegnati con `permitAll()`. Questo significa che qualsiasi richiesta a questi percorsi verrà accettata senza alcuna verifica di identità."
    },
    {
      "artifact_type": "Service Communication",
      "language": "Java (RestTemplate)",
      "negative_example": "String response = restTemplate.getForObject(\"http://policy-management/api/policies/{customerId}\", String.class, customerId);",
      "explanation": "Una chiamata da un servizio a un altro effettuata tramite HTTP semplice senza allegare alcun token di autenticazione (es. JWT, API key) nell'header della richiesta."
    },
    {
      "artifact_type": "Deployment Configuration",
      "language": "Kubernetes (YAML)",
      "negative_example": "# Assenza di un Service Mesh come Istio o Linkerd\n# I servizi comunicano direttamente tramite HTTP",
      "explanation": "L'assenza di un service mesh significa che non c'è un meccanismo standard per applicare mTLS (Mutual TLS) di default. Ogni servizio è responsabile della propria sicurezza, e spesso questa viene omessa per semplicità."
    },
    {
      "artifact_type": "API Gateway Logic",
      "language": "Pseudo-code",
      "negative_example": "route '/internal-api' to 'risk-management-service'\n# No authentication token forwarding",
      "explanation": "L'API Gateway autentica l'utente finale ma non inoltra un token di identità del servizio (o dell'utente) alle chiamate verso i servizi a monte. Il servizio `risk-management` non ha modo di sapere chi sta chiamando."
    },
    {
      "artifact_type": "Controller Method",
      "language": "Node.js (Express)",
      "negative_example": "app.post('/events/new-customer', (req, res) => {\n  // Process event without checking the source\n  eventBus.publish(req.body);\n});",
      "explanation": "Un endpoint che riceve eventi da altri servizi non verifica la sorgente della richiesta. Un servizio compromesso potrebbe iniettare eventi falsi."
    },
    {
      "artifact_type": "Application Configuration",
      "language": "Java (Spring Boot)",
      "negative_example": "security.basic.enabled=false\n# No alternative authentication mechanism is defined for internal endpoints",
      "explanation": "La sicurezza di base è disabilitata, e non viene configurato nessun altro meccanismo (come OAuth2/JWT) per proteggere gli endpoint, lasciando la comunicazione interna non autenticata."
    },
    {
      "artifact_type": "Service Communication",
      "language": "Java",
      "negative_example": "// A service calls another using a client library\n// that has not been configured with any credentials.\nPolicyClient policyClient = new PolicyClient(\"http://policy-service\");\npolicyClient.getPolicies();",
      "explanation": "L'utilizzo di un client SDK per comunicare con un altro servizio senza configurarlo con le credenziali necessarie (API key, token, certificati)."
    },
    {
      "artifact_type": "Asynchronous Communication",
      "language": "Pseudo-code (Messaging)",
      "negative_example": "messageQueue.publish('customer.created', { customerId: '123' });\n// The message has no signature or identity token.",
      "explanation": "Un messaggio inviato a una coda (es. ActiveMQ, RabbitMQ) non contiene alcuna informazione per verificare l'identità del mittente. Qualsiasi servizio con accesso alla coda potrebbe inviare messaggi fraudolenti."
    },
    {
      "artifact_type": "Application Configuration",
      "language": "Java (Spring Security)",
      "negative_example": "@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    public void configure(WebSecurity web) {\n        web.ignoring().antMatchers(\"/internal/**\");\n    }\n}",
      "explanation": "L'uso di `ignoring()` dice a Spring Security di ignorare completamente i percorsi specificati. Nessun contesto di sicurezza viene stabilito, rendendo impossibile qualsiasi forma di autenticazione o autorizzazione per queste rotte."
    },
    {
      "artifact_type": "API Gateway Configuration",
      "language": "YAML (Spring Cloud Gateway)",
      "negative_example": "spring:\n  cloud:\n    gateway:\n      routes:\n      - id: customer_route\n        uri: lb://customer-core\n        predicates:\n        - Path=/customers/**\n        # No filter to add authentication headers to the downstream request",
      "explanation": "La configurazione del gateway instrada la richiesta ma non include un filtro per aggiungere un header di autenticazione (es. `Authorization: Bearer ...`) alla richiesta inviata al servizio `customer-core`."
    }
  ],
  "positive": [
    {
      "artifact_type": "Application Configuration",
      "language": "Java (Spring Security)",
      "positive_example": "http.authorizeRequests().antMatchers(\"/api/internal/**\").hasAuthority(\"SCOPE_internal-service\")",
      "explanation": "Gli endpoint interni richiedono uno specifico 'scope' o 'authority' (tipico di OAuth2), garantendo che solo i client (altri servizi) autorizzati possano invocarli."
    },
    {
      "artifact_type": "Service Communication",
      "language": "Java (RestTemplate)",
      "positive_example": "HttpHeaders headers = new HttpHeaders();\nheaders.setBearerAuth(serviceToken);\nHttpEntity<String> entity = new HttpEntity<>(headers);\nrestTemplate.exchange(\"http://policy-management/api/policies\", HttpMethod.GET, entity, String.class);",
      "explanation": "La chiamata service-to-service include un token JWT (ottenuto tramite client credentials flow di OAuth2) nell'header Authorization, permettendo al servizio ricevente di autenticare il chiamante."
    },
    {
      "artifact_type": "Deployment Configuration",
      "language": "Kubernetes (Istio)",
      "positive_example": "apiVersion: \"security.istio.io/v1beta1\"\nkind: \"PeerAuthentication\"\nmetadata:\n  name: \"default\"\n  namespace: \"lakeside-mutual\"\nspec:\n  mtls:\n    mode: STRICT",
      "explanation": "Un service mesh (Istio) viene configurato per applicare mTLS (Mutual TLS) in modalità STRICT. Tutto il traffico tra i pod nel namespace `lakeside-mutual` verrà automaticamente crittografato e autenticato tramite certificati."
    },
    {
      "artifact_type": "API Gateway Logic",
      "language": "Pseudo-code",
      "positive_example": "route '/internal-api' to 'risk-management-service'\n# Forward the original JWT from the user\nforward header 'Authorization'",
      "explanation": "L'API Gateway inoltra il JWT dell'utente finale al servizio a monte. Questo permette al servizio interno di agire per conto dell'utente e di applicare controlli di autorizzazione basati sull'identità dell'utente originale."
    },
    {
      "artifact_type": "Controller Method",
      "language": "Node.js (Express)",
      "positive_example": "app.post('/events/new-customer', verifyServiceSignature, (req, res) => {\n  // Process verified event\n  eventBus.publish(req.body);\n});",
      "explanation": "Viene utilizzato un middleware (`verifyServiceSignature`) per verificare una firma o un token (es. HMAC, JWT) nella richiesta, garantendo che l'evento provenga da una fonte attendibile."
    },
    {
      "artifact_type": "Application Configuration",
      "language": "Java (Spring Boot)",
      "positive_example": "spring.security.oauth2.resourceserver.jwt.jwk-set-uri=http://auth-server/.well-known/jwks.json",
      "explanation": "Il servizio è configurato come 'resource server' OAuth2. Validerà automaticamente i token JWT in arrivo rispetto a un server di autorizzazione, proteggendo tutti gli endpoint di default."
    },
    {
      "artifact_type": "Asynchronous Communication",
      "language": "Pseudo-code (Messaging)",
      "positive_example": "const payload = { customerId: '123' };\nconst signedPayload = sign(payload, servicePrivateKey);\nmessageQueue.publish('customer.created', { payload, signature: signedPayload });",
      "explanation": "Il payload del messaggio viene firmato digitalmente con la chiave privata del servizio mittente. Il servizio ricevente può quindi verificare la firma usando la chiave pubblica del mittente per garantire l'autenticità."
    },
    {
      "artifact_type": "Service-to-Service Auth",
      "language": "API Key",
      "positive_example": "HttpHeaders headers = new HttpHeaders();\nheaders.set(\"X-API-Key\", serviceApiKey);\nHttpEntity<String> entity = new HttpEntity<>(headers);\n// ... restTemplate call",
      "explanation": "Una forma semplice ma efficace di autenticazione service-to-service, dove un servizio chiamante si identifica usando una API key pre-condivisa. Richiede una gestione sicura delle chiavi."
    },
    {
      "artifact_type": "API Gateway Configuration",
      "language": "YAML (Spring Cloud Gateway)",
      "positive_example": "spring:\n  cloud:\n    gateway:\n      routes:\n      - id: customer_route\n        uri: lb://customer-core\n        predicates:\n        - Path=/customers/**\n        filters:\n        - TokenRelay=",
      "explanation": "Il filtro `TokenRelay` in Spring Cloud Gateway inoltra automaticamente il token OAuth2/JWT della richiesta in arrivo alla richiesta a monte, propagando l'identità di sicurezza."
    },
    {
      "artifact_type": "Application Configuration",
      "language": "Java (Spring Security)",
      "positive_example": "http.authorizeRequests()\n  .anyRequest().authenticated()\n  .and()\n  .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);",
      "explanation": "Una configurazione robusta che richiede l'autenticazione per ogni richiesta e specifica che l'autenticazione deve avvenire tramite la validazione di un token JWT, applicando così una politica di 'deny-by-default'."
    }
  ],
  "potential_risks": [
    "Movimento laterale (Lateral Movement): un attaccante che compromette un servizio può attaccarne altri.",
    "Spoofing di servizi: un servizio malevolo può impersonare uno legittimo per richiedere dati o eseguire azioni.",
    "Iniezione di dati/eventi malevoli nel sistema.",
    "Difficoltà nell'auditing e nel tracciamento delle richieste, poiché l'origine non è verificabile."
  ],
  "metadata": {
    "tags": [
      "Authentication",
      "Service-to-Service",
      "Zero Trust",
      "JWT",
      "mTLS"
    ],
    "remediation_difficulty": "High",
    "impact": "High"
  }
}
